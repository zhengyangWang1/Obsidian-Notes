---
title: Scheduling调度
categories:
  - Notes
  - 课程
  - 操作系统
tags:
  - 操作系统
date:
---
调度有两个方面：
1）如何从一个进程切换到另一个进程
2）下一个应该运行什么进程
机制：上下文切换（如何切换）
机制：抢占（保持控制）
策略：调度（切换到哪里）

上下文切换是一种允许操作系统存储当前进程状态并切换到另一个先前存储的上下文的机制。
上下文切换的原因： 
进程完成/退出 
进程执行缓慢的硬件操作（例如，从磁盘加载）并且操作系统切换到另一个就绪任务 
硬件需要操作系统帮助并发出中断 
操作系统决定抢占该任务并切换到另一个任务（即该进程已用完其时间片）

异步返回的函数调用：进程A开始执行上下文切换，但进程B在函数返回后继续执行。
该函数将所有寄存器保存在暂存区域（在进程的内核堆栈上或任务结构的预定义区域中）。
操作系统切换地址空间。
该函数从暂存区恢复所有寄存器。
操作系统返回到进程B。

如果任务从未放弃控制权 (yield())、退出或执行 I/O，那么它可以永远运行，并且操作系统无法获得控制权。
因此，操作系统在调度进程之前设置一个计时器。如果定时器到期，硬件就会中断进程的执行并切换到内核。然后内核决定该进程是否可以继续。

上下文切换机制负责​​内核如何从一个进程切换到另一个进程，即通过存储其上下文并恢复另一个进程的上下文。调度策略决定接下来应该运行哪个进程。如果只有一个“就绪”进程，那么答案很简单。如果有更多进程，则策略决定进程的执行顺序。

在分析调度程序策略时，我们使用以下术语： 
利用率：CPU 执行程序的时间比例（目标：最大化） 
周转时间：完成作业所需的总时间，$T_{completion} − T_{arrival}$（目标：最小化） 
响应时间：从作业到达到第一次调度的时间，$T_{firstrun} - T_{arrival}$（目标：最小化） 
公平性：所有进程随着时间的推移获得相同数量的 CPU（目标：无饥饿） 
进度：允许进程向前推进（目标：最小化内核中断）

让我们逐步了解调度策略。我们从一些简化假设开始 
每个作业的运行时间相同 
所有作业在同一时间到达 一旦启动，每个作业都会运行到完成 
所有作业只使用 CPU（无 I/O） 
作业的运行时间已知 


### 调度的三个层次
#### 高级调度
按一定原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。

#### 中级调度
内存中暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织成挂起队列
中级调度按照某种策略决定将哪个处于挂起状态的进程重新调入内存。

#### 低级调度（进程调度）
按某种策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，进程调度的频率很高，一般几十毫秒一次。

### 进程调度的时机
- 当前进程主动放弃处理机
- 当前进程被动放弃处理机
![image.png](https://cdn.jsdelivr.net/gh/zhengyangWang1/image@main/img/20231104113430.png)

不能进行进程调度与切换的情况：![image.png](https://cdn.jsdelivr.net/gh/zhengyangWang1/image@main/img/20231104113457.png)
### 进程调度的方式
- 非抢占式
- 抢占式：优先处理更紧急的进程

进程切换的过程：
1. 对原来运行进程各种数据的保存
2. 对新的进程各种数据的恢复
进程切换是有代价的

### 调度程序
决定让谁运行，以及运行多长时间
抢占式调度策略在时钟中断时唤醒调度程序

闲逛进程（idle）：
- 优先级最低
- 可以是0地址指令，占一个完整的指令周期
- 能耗低

### CPU利用率
利用率=忙碌的时间/总时间

周转时间：作业被提交给系统开始，到作业完成为止需要的时间。包括四个部分：
- 作业在外存后备队列上等待作业调度（高级调度）的时间
- 进程在就绪队列上等待进程调度的时间
- 进程在CPU上执行的时间
- 进程等待I/O操作完成的时间

平均周转时间：各作业周转时间之和/作业数
![image.png](https://cdn.jsdelivr.net/gh/zhengyangWang1/image@main/img/20231104115312.png)

等待时间：进程处于等待处理机状态时间之和

响应时间：用户从提出请求到首次产生响应所用的时

### 调度算法
#### 先来先服务（FCFS）
按照到达的先后顺序，等待时间越久的越先得到服务。
例题：![image.png](https://cdn.jsdelivr.net/gh/zhengyangWang1/image@main/img/20231104145306.png)
非抢占式算法
优点：公平，算法实现简单
缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大。即FCFS算法**对长作业有利，对短作业不利**。

不会导致饥饿

#### 短作业优先（SJF）
每次调度时选择当前已到达且运行时间最短的进程。
例题：![image.png](https://cdn.jsdelivr.net/gh/zhengyangWang1/image@main/img/20231104150027.png)
非抢占式算法

##### 抢占式的短作业优先算法：最短剩余时间优先算法（SRTN）
每当有进程加入，就绪队列改变时就需要调度，如果新到达进程的剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前进程回到就绪队列。
例题：![image.png](https://cdn.jsdelivr.net/gh/zhengyangWang1/image@main/img/20231104150908.png)![image.png](https://cdn.jsdelivr.net/gh/zhengyangWang1/image@main/img/20231104150952.png)
未特别说明，短作业优先算法默认是非抢占式的