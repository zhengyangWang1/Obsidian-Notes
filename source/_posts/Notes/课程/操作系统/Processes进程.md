---
title: Processes进程
categories:
  - Notes
  - 课程
  - 操作系统
tags:
  - 操作系统
date:
---
为什么我们需要同时运行多个程序？称为“多道程序设计” 因为它会提高 CPU 利用率 
I/O 密集型程序大部分时间都在等待 I/O，因此最好让 CPU 忙于其他任务

多道程序设计：在一个物理地址空间中容纳多个进程 每个进程可以是 I/O 密集型或 CPU 密集型 混合使用 I/O 密集型和 CPU 密集型进程会很好 目标是提高 CPU 利用率 调度程序决定哪个进程执行

分时（或“多任务”）：非常快速地在进程之间来回切换 - 称为“上下文切换” 
目标是减少用户与计算机交互时的延迟

程序由静态代码和数据（如磁盘上的数据）组成。 进程是程序的运行实例。在任何时候，一个程序都可能有 0 个或多个运行实例，例如，一个用户可能同时运行多个 shell

从运行时上下文的角度来看，进程是一个执行流。执行流是​​执行指令的序列（即“控制线程”）。运行时上下文包含执行指令可能影响或受其影响的所有内容（例如，寄存器、地址空间、文件等持久数据）

进程可访问的一组内存部分称为进程的地址空间 
- 文本 — 程序代码（通常是只读） 
- 数据 — 全局变量和常量 
- 栈（Stack） — 每个帧包含参数、局部变量和函数的返回地址 
- 堆（Heap）— 动态分配内存，例如，通过在 C 中调用 malloc()

允许在同一物理地址空间中执行多个程序 
虚拟化CPU：多个独立进程同时运行在一台物理机上 但实际上，每个CPU上任一时刻最多只能有一个进程处于活动状态。

程序是磁盘上的应用程序，由代码和数据组成；
**程序在执行时就成为进程**。**进程是程序的运行实例**。进程以单个执行线程和地址空间开始。一个进程可以在同一地址空间中启动多个执行线程。**每个线程都有自己的堆栈**，但它们**共享全局数据、代码和堆**。

当用户执行程序时，操作系统会创建一个进程。操作系统在多个进程之间分时共享 CPU。操作系统调度程序选择要运行的可执行进程之一。
调度程序必须保留进程列表 
调度程序必须保留调度策略的元数据

策略和机制之间的区别可以实现模块化。调度策略独立于上下文切换功能。

运行（Running）：此进程当前正在执行 
就绪（Ready）：此进程已准备好执行（并且将在策略决定时进行调度） 
阻塞（Blocked）：此进程已挂起（例如，等待某些操作；当该操作完成时，操作系统将取消阻止它） 
New：此进程正在创建（以确保它不会被调度） Dead/termination：此进程已终止（例如，如果父进程尚未读出返回值）

如果所有进程都被阻塞，应该调度什么进程？空闲进程（idle）。现代内核使用低优先级空闲进程，如果没有其他进程准备好，该进程就会被调度并执行。空闲进程从不阻塞或执行任何 I/O。空闲进程是解决挑战性问题的简单方法。如果没有空闲进程，调度程序将必须检查是否没有进程准备好运行，并且必须保守地采取行动。空闲进程保证至少有一个进程可以运行

操作系统维护活动进程的数据结构（数组/列表）。每个进程的信息都存储在进程控制块（在 Linux 上，称为 task_struct）中，其中包含： 
进程标识符 (PID) 
进程状态（例如，就绪） 
指向父进程的指针 (cat /proc/self/status) 
CPU 上下文（如果进程未运行） 
指向地址空间的指针 (cat /proc/self/maps) 
指向打开文件列表的指针（文件描述符，cat /proc/self/fdinfo/\*）

保存进程的所有状态允许进程暂时挂起并稍后从同一点恢复
然后可以通过恢复其保存的状态来恢复另一个进程
执行上下文切换所需的时间是我们希望最小化的开销

程序：由磁盘上的可执行文件组成。包含启动进程的所有信息 
进程：程序的运行实例；具有数据部分和堆栈初始化
线程：一个进程可以在同一地址空间中拥有多个线程（计算相同的数据）

读取地址0xc0f3的两个进程可能读取到不同的值。而同一进程中的两个线程会读取相同的值

进程可以通过系统调用API（应用程序编程接口）请求服务